#!/usr/bin/env python


def main(argv=None):
    from argparse import ArgumentParser
    from itertools import chain, cycle, product 
    from os import path
    from sys import exit

    from yaml import load as yload

    argparser = ArgumentParser(description='create experiment execution plan' +
                                           'using orthogonal arrays')

    # FIXME: var on command line like template render?

    argparser.add_argument('-c', '--config',
                           help='experiment configuration file')

    argparser.add_argument('-d', '--oadir', default='.',
                           help='directory containing orthogonal array files')
    
    args = argparser.parse_args()

    if not args.config or not path.isfile(args.config):
        raise SystemExit('configuration file required to run experiment.')
    
    config = yload(open(args.config, 'r'))

    oadir = args.oadir

    if not oadir or not path.isdir(oadir):
        raise SystemExit("invalid orthogonal array directory: %s" % (oadir))

    commandsets = config.get('commandsets', [])

    paramsets = config.get('paramsets', [])

    selections = {}

    for paramsetname, paramset in paramsets.iteritems():

        selection = []
        array = paramset.get('array', 'full-factorial') # full-fact default
        params = paramset.get('params', [])
        num_params = len(params)

        # FIXME: make function...
        oa = []
        if array.startswith('file:'): 
            arrayfile = path.join(oadir, array[5:])
            # FIXME: convert to try/catch
            if not path.isfile(arrayfile):
                raise SystemExit("not a valid array file: %s" % (arrayfile))
            oa = [[int(x) for x in r.split()] for r in open(arrayfile, 'r')]
        elif array == 'full-factorial':
            col_idx = 0
            levels = []
            for pspec in params.values():
                pspec['col'] = col_idx
                col_idx += 1
                levels.append([[x] for x in range(len(pspec['values']))])
            # convert list of lists of levels to list of lists representing
            # combindations of levels...
            oa = reduce(lambda x, y: [w+v for w in x for v in y], levels)
        else:
            # FIXME: add support for named arrays / mongo or other db...
            pass

        oa_cols = zip(*oa)
        oa_avail_cols = set(range(len(oa_cols)))

        # FIXME: should properly handle only specifying some columns
        for pname, pspec in params.iteritems():
            pcolidx = pspec.get('col', -1)
            if pcolidx < 0:
                # FIXME: exception if out of columns?
                pcolidx = oa_avail_cols.pop()
            else:
                # FIXME: exception if column not available?
                oa_avail_cols.discard(pcolidx)
                
            pvalues = pspec.get('values', [])
            pcol = oa_cols[pcolidx]

            num_values = len(pvalues)
            num_indexes = len(set(pcol))

            if num_values > num_indexes:
                raise SystemExit("The number of parameter values exceeds the " +
                                 "number of indexes available")
        
            maxidx = (num_indexes / num_values) * num_values - 1
            pvalcycle = cycle(pvalues)
            selection.append([(pname, pvalues[i % num_values]) if i <= maxidx
                             else next(pvalcycle) for i in pcol])
 
        selections[paramsetname] = zip(*selection)

    # FIXME: need to instantiate variables here, into list of dicts with keys
    # 'paramsets' pointing to set and 'variables' with names and lists of
    # values...

    for commandset in commandsets:
        cparamsets = commandset['paramsets']
        a = [selections[pname] for pname in cparamsets]
        b = reduce(lambda x, y: [list(w)+list(v) for w in x for v in y], a)
        plan = [dict(list(r) + [('index', i)]) for i, r in enumerate(b)]
        
        variables = [var for var in config['variables'] 
                     if frozenset(var['paramsets']) <= frozenset(cparamsets)]

        for row in plan:
            row['index'] = row['index'] // 3630 # FIXME: hack for vpexp experiment!
            row.update(config['constants'])
            for var in variables:
                    row[var['name']] = var['value'] % row                
            commandinsts = set([])
            for command in commandset['commands']:
                commandinst = command % row
                if commandinst not in commandinsts:
                    print command % row
                commandinsts.add(commandinst)
    

if __name__ == "__main__":
    main()
 
