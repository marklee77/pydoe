#!/usr/bin/env python

def main(argv=None):
    from argparse import ArgumentParser
    import os.path
    from itertools import chain, cycle, product 
    from sys import exit

    from yaml import load as yload

    argparser = ArgumentParser(description='run vector packing experiment')
    argparser.add_argument('-c', '--config',
                           help='experiment configuration file')

    # FIXME: var on command line like template render?
    argparser.add_argument('-d', '--oadir', default='.',
                           help='directory containing orthogonal array files')
    
    args = argparser.parse_args()

    if not args.config or not os.path.isfile(args.config):
        raise SystemExit("configuration file required to run experiment.")
    
    config = yload(open(args.config, 'r'))

    oadir = args.oadir

    commandsets = config.get('commandsets', [])

    paramsets = config.get('paramsets', [])

    selections = {}

    for paramsetname, paramset in paramsets.iteritems():

        selection = []
        array = paramset.get('array', 'full-factorial') # full-factorial default
        params = paramset.get('params', [])
        num_params = len(params)

        oa = []
        if array.startswith('file:'): 
            arrayfile = os.path.join(oadir, array[5:])
            if not os.path.isfile(arrayfile):
                raise SystemExit("not a valid array file: %s" % (arrayfile))
            oa = [[int(x) for x in r.split()] for r in open(arrayfile, 'r')]
        elif array == 'full-factorial':
            col_idx = 0
            levels = []
            for pspec in params.values():
                pspec['col'] = col_idx
                levels.append(map(lambda x: [x], range(len(pspec['values']))))
                col_idx += 1
            oa = reduce(lambda x, y: [w+v for w in x for v in y], levels)
        else:
            # FIXME: add support for named arrays / mongo or other db...
            pass

        oa_trans = zip(*oa)
        oa_cols = zip(*oa)
        oa_avail_cols = set(range(len(oa_cols)))

        for pname, pspec in params.iteritems():
            pcolidx = pspec.get('col', -1)
            if pcolidx < 0:
                # FIXME: exception if out of columns?
                pcolidx = oa_avail_cols.pop()
            else:
                # FIXME: exception if column not available?
                oa_avail_cols.discard(pcolidx)
                
            pvalues = pspec.get('values', [])
            pcol = oa_cols[pcolidx]

            num_values = len(pvalues)
            num_symbols = len(set(pcol))

            if num_values > num_symbols:
                raise SystemExit("The number of parameter values exceeds the " +
                                 "number of symbols available")
        
            maxidx = (num_symbols / num_values) * num_values - 1
            pvalcycle = cycle(pvalues)
            selection.append([(pname, pvalues[i % num_values]) if i <= maxidx
                             else next(pvalcycle) for i in pcol])
 
        selections[paramsetname] = zip(*selection)

    
    for commandset in commandsets:
        #plan = [dict(list(row) + [('index', index)]) for index, row in enumerate(reduce(lambda x, y: [list(w)+list(v) for w in x for v in y], map(selections.get, commandset['paramsets'])))]
        a = [selections[pname] for pname in commandset['paramsets']]
        b = reduce(lambda x, y: [list(w)+list(v) for w in x for v in y], a)
        plan = [dict(list(r) + [('index', i)]) for i, r in enumerate(b)]

        for row in plan:
            row.update(config['constants'])
            row['probfile'] = 'PROBFILE'
            row['resultfile'] = 'RESULTFILE'
            for command in commandset['commands']:
                print command % row
    

if __name__ == "__main__":
    main()
 
