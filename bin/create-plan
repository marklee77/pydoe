#!/usr/bin/env python


def main(argv=None):
    from argparse import ArgumentParser
    import os.path
    from itertools import chain, cycle, product 
    from sys import exit

    from yaml import load as yload

    argparser = ArgumentParser(description='run vector packing experiment')
    argparser.add_argument('-c', '--config',
                           help='experiment configuration file')

    # FIXME: var on command line like template render?
    argparser.add_argument('-d', '--oadir', default='.',
                           help='directory containing orthogonal array files')
    
    args = argparser.parse_args()

    if not args.config or not os.path.isfile(args.config):
        raise SystemExit("configuration file required to run experiment.")
    
    config = yload(open(args.config, 'r'))

    oadir = args.oadir

    commandsets = config.get('commandsets', [])

    paramsets = config.get('paramsets', [])

    selections = {}

    for paramsetname, paramset in paramsets.iteritems():

        selection = []
        array = paramset.get('array', 'full-factorial') # full-factorial default
        params = paramset.get('params', [])
        num_params = len(params)

        oa = []
        if array.startswith('file:'): 
            arrayfile = os.path.join(oadir, array[5:])
            if not os.path.isfile(arrayfile):
                raise SystemExit("not a valid array file: %s" % (arrayfile))
            oa = [[int(x) for x in r.split()] for r in open(arrayfile, 'r')]
        elif array == 'full-factorial':
            col_idx = 0
            levels = []
            for pspec in params.values():
                pspec['col'] = col_idx
                levels.append(map(lambda x: [x], range(len(pspec['values']))))
                col_idx += 1
            oa = reduce(lambda x, y: [w+v for w in x for v in y], levels)
        else:
            # FIXME: add support for named arrays / mongo or other db...
            pass

        oa_trans = zip(*oa)
        oa_cols = zip(*oa)
        oa_avail_cols = set(range(len(oa_cols)))

        for pname, pspec in params.iteritems():
            pcolidx = pspec.get('col', -1)
            if pcolidx < 0:
                # FIXME: exception if out of columns?
                pcolidx = oa_avail_cols.pop()
            else:
                # FIXME: exception if column not available?
                oa_avail_cols.discard(pcolidx)
                
            pvalues = pspec.get('values', [])
            pcol = oa_cols[pcolidx]

            num_values = len(pvalues)
            num_symbols = len(set(pcol))

            if num_values > num_symbols:
                raise SystemExit("The number of parameter values exceeds the " +
                                 "number of symbols available")
        
            maxidx = (num_symbols / num_values) * num_values - 1
            pvalcycle = cycle(pvalues)
            selection.append([(pname, pvalues[i % num_values]) if i <= maxidx
                             else next(pvalcycle) for i in pcol])
 
        selections[paramsetname] = zip(*selection)

    for commandset in commandsets:
        cparamsets = commandset['paramsets']
        a = [selections[pname] for pname in cparamsets]
        b = reduce(lambda x, y: [list(w)+list(v) for w in x for v in y], a)
        plan = [dict(list(r) + [('index', i)]) for i, r in enumerate(b)]
        
        variables = [var for var in config['variables'] 
                     if frozenset(var['paramsets']) <= frozenset(cparamsets)]

        for row in plan:
            row.update(config['constants'])
            for var in variables:
                    row[var['name']] = var['value'] % row                
            commandinsts = set([])
            for command in commandset['commands']:
                commandinst = command % row
                if commandinst not in commandinsts:
                    print command % row
                commandinsts.add(commandinst)
    

if __name__ == "__main__":
    main()
 
