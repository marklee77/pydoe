#!/usr/bin/env python

def main(argv=None):
    from argparse import ArgumentParser
    from os.path import isfile
    from itertools import chain, cycle, product 
    from sys import exit

    from yaml import load as yload

    argparser = ArgumentParser(description='run vector packing experiment')
    argparser.add_argument('-c', '--config',
                           help='experiment configuration file')

    argparser.add_argument('-a', '--array', action='append', default=[],
                           help='input file containing orthogonal array')
    
    argparser.add_argument('-s', '--seed', type=int, default=0,
                           help='initial random seed value')

    args = argparser.parse_args()

    if not args.config or not isfile(args.config):
        raise SystemExit("configuration file required to run experiment.")
    
    config = yload(open(args.config, 'r'))

    oas = []

    for arrayfile in args.array:
        if not isfile(arrayfile):
            raise SystemExit("not a valid array file: %s", arrayfile)

        oas.append([[int(x) for x in r.split()] 
                           for r in open(arrayfile, 'r')])

    paramsets = config.get('params', [])
    commands  = config.get('commands', [])

    if len(paramsets) != len(oas):
        raise SystemExit("must specify an array file for every paramset.")

    selections = []
    for paramset, oa in zip(paramsets, oas):
        selection = []
        for (param, pvalues), col in zip(paramset.iteritems(), zip(*oa)):
            num_values = len(pvalues)
            num_symbols = len(set(col))
            if num_values > num_symbols:
                raise SystemExit("The number of parameter values exceeds the " +
                                 "number of symbols available")
            maxval = (num_symbols / num_values) * num_values
            cval = cycle(pvalues)
            
            selection.append([(param, pvalues[idx % num_values])
                             if idx < maxval else next(cval) for idx in col])
        selections.append(zip(*selection))

    #plan = reduce(lambda x, y: [chain(*z) for z in product(x, y)], selections)
    plan = [dict(row) for row in reduce(lambda x, y: [list(w)+list(v) for w in x for v in y], selections)]

    for row in plan:
        for command in commands: 
            print command % row
    

if __name__ == "__main__":
    main()
 
